name: Release

on:
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'examples/**'
      - '.gitignore'
      - 'LICENSE'
  workflow_dispatch:

permissions:
  contents: write
  packages: write
  id-token: write

env:
  GO_VERSION: '1.24'

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run tests
        run: make test

      - name: Run linters
        uses: golangci/golangci-lint-action@v8
        with:
          version: v2.1
          args: --timeout=5m

  release:
    name: Release
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Install cosign
      uses: sigstore/cosign-installer@v3

    - name: Generate tag
      id: tag
      run: |
        # Get the latest tag
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"
        
        # Extract version numbers
        VERSION=$(echo $LATEST_TAG | sed 's/^v//')
        IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
        MAJOR=${VERSION_PARTS[0]:-0}
        MINOR=${VERSION_PARTS[1]:-0}
        PATCH=${VERSION_PARTS[2]:-0}
        
        # Increment patch version
        NEW_PATCH=$((PATCH + 1))
        NEW_TAG="v${MAJOR}.${MINOR}.${NEW_PATCH}"
        
        echo "New tag: $NEW_TAG"
        echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT

    - name: Create and push tag
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag ${{ steps.tag.outputs.tag }}
        git push origin ${{ steps.tag.outputs.tag }}

    - name: Run GoReleaser
      uses: goreleaser/goreleaser-action@v5
      with:
        distribution: goreleaser
        version: latest
        args: release --clean
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # Container signing disabled until Docker builds are re-enabled
    # - name: Sign container images
    #   run: |
    #     cosign sign --yes ghcr.io/${{ github.repository }}:${{ steps.tag.outputs.tag }}
    #     cosign sign --yes ghcr.io/${{ github.repository }}:latest
    #   env:
    #     COSIGN_EXPERIMENTAL: 1

  # homebrew:
  #   name: Update Homebrew
  #   runs-on: ubuntu-latest
  #   needs: release
  #   if: startsWith(github.ref, 'refs/tags/v')
  #   
  #   steps:
  #   - name: Update Homebrew formula
  #     uses: dawidd6/action-homebrew-bump-formula@v3
  #     with:
  #       token: ${{ secrets.HOMEBREW_TOKEN }}
  #       formula: fast-cc-hooks
  #       tag: ${{ github.ref }}
  #       revision: ${{ github.sha }}

  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [release]  # removed homebrew dependency
    if: always()
    
    steps:
    - name: Notify on success
      if: needs.release.result == 'success'
      run: |
        echo "Release completed successfully!"
        # Add notification logic here (Slack, Discord, etc.)
        
    - name: Notify on failure
      if: needs.release.result == 'failure'
      run: |
        echo "Release failed!"
        # Add failure notification logic here