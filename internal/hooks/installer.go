// Package hooks provides git hook installation and management.
package hooks

import (
	"context"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

const (
	// HookName is the name of the commit-msg hook.
	HookName = "commit-msg"
	// BackupSuffix is appended to backup files.
	BackupSuffix = ".backup"
	// HookIdentifier identifies our hooks.
	HookIdentifier = "# fast-cc-hooks"
)

var (
	// ErrNoGitRepo indicates .git directory not found.
	ErrNoGitRepo = errors.New("not a git repository")
	// ErrHookExists indicates hook already exists.
	ErrHookExists = errors.New("hook already exists")
)

// Installer manages git hook installation.
type Installer struct {
	logger       *slog.Logger
	gitDir       string
	executable   string
	forceInstall bool
}

// Options configures the Installer.
type Options struct {
	Logger       *slog.Logger
	GitDir       string
	Executable   string
	ForceInstall bool
}

// New creates a new Installer.
func New(opts Options) (*Installer, error) {
	if opts.Logger == nil {
		opts.Logger = slog.Default()
	}

	gitDir := opts.GitDir
	if gitDir == "" {
		dir, err := findGitDir()
		if err != nil {
			return nil, err
		}
		gitDir = dir
	}

	executable := opts.Executable
	if executable == "" {
		exe, err := os.Executable()
		if err != nil {
			return nil, fmt.Errorf("finding executable: %w", err)
		}
		executable = exe
	}

	return &Installer{
		logger:       opts.Logger,
		gitDir:       gitDir,
		executable:   executable,
		forceInstall: opts.ForceInstall,
	}, nil
}

// Install installs the commit-msg hook.
func (i *Installer) Install(ctx context.Context) error {
	hooksDir := filepath.Join(i.gitDir, "hooks")

	// Ensure hooks directory exists.
	if err := os.MkdirAll(hooksDir, 0o755); err != nil {
		return fmt.Errorf("creating hooks directory: %w", err)
	}

	hookPath := filepath.Join(hooksDir, HookName)

	// Check if hook already exists.
	if info, err := os.Stat(hookPath); err == nil {
		if !i.forceInstall {
			// Check if it's our hook.
			if i.isOurHook(hookPath) {
				i.logger.Info("hook already installed", "path", hookPath)
				return nil
			}
			return fmt.Errorf("%w: %s (use --force to override)", ErrHookExists, hookPath)
		}

		// Backup existing hook.
		if err := i.backupHook(hookPath, info); err != nil {
			return fmt.Errorf("backing up existing hook: %w", err)
		}
	}

	// Create hook script.
	script := i.generateHookScript()

	// Write hook file.
	if err := os.WriteFile(hookPath, []byte(script), 0o755); err != nil {
		return fmt.Errorf("writing hook: %w", err)
	}

	i.logger.Info("hook installed successfully",
		"path", hookPath,
		"executable", i.executable)

	return nil
}

// Uninstall removes the commit-msg hook.
func (i *Installer) Uninstall(ctx context.Context) error {
	hookPath := filepath.Join(i.gitDir, "hooks", HookName)

	// Check if hook exists.
	if _, err := os.Stat(hookPath); os.IsNotExist(err) {
		i.logger.Info("hook not installed", "path", hookPath)
		return nil
	}

	// Verify it's our hook before removing.
	if !i.isOurHook(hookPath) {
		return fmt.Errorf("hook exists but was not installed by fast-cc-hooks: %s", hookPath)
	}

	// Remove the hook.
	if err := os.Remove(hookPath); err != nil {
		return fmt.Errorf("removing hook: %w", err)
	}

	// Check for backup and restore if exists.
	backupPath := hookPath + BackupSuffix
	if _, err := os.Stat(backupPath); err == nil {
		if err := os.Rename(backupPath, hookPath); err != nil {
			i.logger.Warn("failed to restore backup", "error", err)
		} else {
			i.logger.Info("restored original hook from backup")
		}
	}

	i.logger.Info("hook uninstalled successfully", "path", hookPath)
	return nil
}

// IsInstalled checks if the hook is installed.
func (i *Installer) IsInstalled() bool {
	hookPath := filepath.Join(i.gitDir, "hooks", HookName)
	return i.isOurHook(hookPath)
}

// generateHookScript creates the hook script content.
func (i *Installer) generateHookScript() string {
	var sb strings.Builder

	sb.WriteString("#!/bin/sh\n")
	sb.WriteString(HookIdentifier + "\n")
	sb.WriteString("# Auto-generated by fast-cc-hooks\n")
	sb.WriteString(fmt.Sprintf("# Generated at: %s\n", time.Now().Format(time.RFC3339)))
	sb.WriteString("\n")

	// Add hook logic.
	sb.WriteString("# Validate commit message\n")
	sb.WriteString(fmt.Sprintf("exec %q validate --file \"$1\"\n", i.executable))

	return sb.String()
}

// isOurHook checks if a hook file was created by us.
func (i *Installer) isOurHook(path string) bool {
	file, err := os.Open(path)
	if err != nil {
		return false
	}
	defer file.Close()

	// Read first few lines to check for identifier.
	buf := make([]byte, 256)
	n, _ := file.Read(buf)
	content := string(buf[:n])

	return strings.Contains(content, HookIdentifier)
}

// backupHook creates a backup of an existing hook.
func (i *Installer) backupHook(path string, info os.FileInfo) error {
	backupPath := path + BackupSuffix

	// Don't backup if it already exists.
	if _, err := os.Stat(backupPath); err == nil {
		i.logger.Warn("backup already exists, skipping", "path", backupPath)
		return nil
	}

	// Copy the file.
	src, err := os.Open(path)
	if err != nil {
		return err
	}
	defer src.Close()

	dst, err := os.Create(backupPath)
	if err != nil {
		return err
	}
	defer dst.Close()

	if _, err := io.Copy(dst, src); err != nil {
		return err
	}

	// Preserve permissions.
	if err := dst.Chmod(info.Mode()); err != nil {
		return err
	}

	i.logger.Info("created backup", "path", backupPath)
	return nil
}

// findGitDir locates the .git directory.
func findGitDir() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", fmt.Errorf("getting working directory: %w", err)
	}

	// Walk up directory tree looking for .git.
	for {
		gitDir := filepath.Join(dir, ".git")
		if info, err := os.Stat(gitDir); err == nil {
			if info.IsDir() {
				return gitDir, nil
			}
			// Handle git worktrees (.git as file).
			if content, err := os.ReadFile(gitDir); err == nil {
				if strings.HasPrefix(string(content), "gitdir:") {
					gitPath := strings.TrimSpace(strings.TrimPrefix(string(content), "gitdir:"))
					if !filepath.IsAbs(gitPath) {
						gitPath = filepath.Join(dir, gitPath)
					}
					return gitPath, nil
				}
			}
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			break // Reached root.
		}
		dir = parent
	}

	return "", ErrNoGitRepo
}

// GlobalInstall installs hooks globally for all repositories.
func GlobalInstall(ctx context.Context, logger *slog.Logger) error {
	// Get git config directory.
	configDir, err := getGitConfigDir()
	if err != nil {
		return fmt.Errorf("finding git config directory: %w", err)
	}

	templateDir := filepath.Join(configDir, "hooks")
	if err := os.MkdirAll(templateDir, 0o755); err != nil {
		return fmt.Errorf("creating template directory: %w", err)
	}

	// Configure git to use template directory.
	if err := configureGitTemplate(templateDir); err != nil {
		return fmt.Errorf("configuring git template: %w", err)
	}

	// Install hook in template directory.
	opts := Options{
		Logger:       logger,
		GitDir:       filepath.Dir(templateDir), // Parent of hooks dir
		ForceInstall: true,
	}

	installer, err := New(opts)
	if err != nil {
		return err
	}

	return installer.Install(ctx)
}

// getGitConfigDir returns the git configuration directory.
func getGitConfigDir() (string, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}

	// Check XDG_CONFIG_HOME first.
	if xdg := os.Getenv("XDG_CONFIG_HOME"); xdg != "" {
		return filepath.Join(xdg, "git"), nil
	}

	// Default locations.
	switch runtime.GOOS {
	case "windows":
		return filepath.Join(home, "AppData", "Roaming", "Git"), nil
	default:
		return filepath.Join(home, ".config", "git"), nil
	}
}

// configureGitTemplate sets up git to use our template directory.
func configureGitTemplate(templateDir string) error {
	// This would typically call git config.
	// For now, we'll document that users need to run:.
	// git config --global init.templateDir <templateDir>.
	return nil
}
